# takes a table generated by the database software and combines the measurement types

# -*- coding: utf-8 -*-
"""
Created on Tue Nov  3 14:24:17 2020

@author: royal
"""
# to use it to concatenate tables, you want to createTable from the input file
# then append more files to the first created table with appendCSV
# once enough tables are appended, you can run queryTableExport

import pandas as pd
import argparse
import numpy as np
import operator as op
#from multipledispatch import dispatch

Columns = []

#df = pd.DataFrame

# this helper function is straight from https://www.pythoncentral.io/how-to-check-if-a-string-is-a-number-in-python-including-unicode/
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        pass
 
    try:
        import unicodedata
        unicodedata.numeric(s)
        return True
    except (TypeError, ValueError):
        pass
 
    return False

def createTable(inputfile):
    #print(inputfile)
    workingDf = pd.read_csv(inputfile)
    #print(workingDf)
    return workingDf

def appendCSV(workingDf, inputfile):
    df2 = createTable(inputfile)
    print("input from ", inputfile, df2)
    workingDf = pd.concat([workingDf, df2], ignore_index=True)
    return workingDf  

# what should we rename this function to? 
def nonCLI(inputfile, outputfile, query):
    #print(inputfile, outputfile)
    inputDf = pd.read_csv(inputfile)
    #print(inputDf)
    outputDf = pd.DataFrame()
    print("Will attempt to use function parameters as filenames for ", query, ", working...")

    # if (query == "Ipsilateral Impact"): #ipsi impact / pushoff?
    #     outputDf = goQuery1(inputDf)
    # if (query == "Ipsilateral Pushoff"):
    #     outputDf = goQuery2(inputDf)
    # if (query == "Ipsilateral Mostly Impact"):
    #     outputDf = goQuery3(inputDf)
    # if (query == "Just Impact"):
    #     outputDf = goQuery5(inputDf)
    # if (query == "Just Pushoff"):
    #     outputDf = goQuery6(inputDf)
    if (query == "pdn"):
        #we should also rename this function and the above string. 
        #maybe "PDN + Extra Blocks?"
        outputDf = goPDNQuery(inputDf)
    if (query == "OnlyPDN"):
        outputDf = queryOnlyPDN(inputDf)

    #print(outputDf)
    outputDf.to_csv(outputfile)
    print("\n\nExported to", outputfile)

    
def exportTable(inputDf, outputfile):
    print("\nExporting to", outputfile)
    #print("input data:", inputDf)
    #print("Will attempt to usse function parameter as inputDf, output filename, working...")
    print(inputDf)
    inputDf.to_csv(outputfile)
    print("\nExported to", outputfile)
    
def goPDNQuery(inputDf):
    print("\n\nPDN QUERY \n\n")

    df1 = inputDf.copy()
    # df1 = filterTable(df1, "Trial", "==", "Straight Line")
    # df1 = filterTable(df1, "Fore Strides", ">", "19")

    dfPDN1 = filterTable(df1, "Blocks", "contains", "PDN")
    # standard in Blocks is "RH: PDN" for example. If there are more than 7 characters
    # in Blocks, that means that there is more than just 1 block. 
    mask = (dfPDN1['Blocks'].str.len() > 7)
    dfPDN1 = dfPDN1.loc[mask]
    dfPDN1 = dfPDN1.loc[:, ['Horse', 'When']]

    # need to slice the date (first 8 characters) out of the 'When' column and keep.
    # TODO: dates are not consistnent string lengths

    df1['When'] = df1['When'].str[:9]
    dfPDN1['When'] = dfPDN1['When'].str[:9]
    dfPDN1 = pd.DataFrame.drop_duplicates(dfPDN1)
    # now dfPDN1 should just be the list of horse names and dates and times. 
    print("About to get all trials for Names on certain Date")
    
    outputDf = pd.DataFrame(columns=df1.columns)
    print("outputDF", outputDf)
    
    # function: give back results from original df1 where the horse names and dates are the same.
    for _, row in dfPDN1.iterrows():
        #print("row.Horse", row.Horse, "row.When", row.When)
        tempDf =  df1.copy()
        
        tempDf = filterTable(tempDf, "Horse", "==", row.Horse)
        tempDf = filterTable(tempDf, "When", "==", row.When)
        #print(tempDf)
        #add row to output DF
        outputDf = outputDf.append(tempDf)
        #print(outputDf)

    df0 = outputDf.copy()
    df0 = filterTable(df0, "Trial", "==", "Straight Line")
    df0 = filterTable(df0, "Fore Strides", ">", "19")
    return df0
    
def queryOnlyPDN(inputDf):
    print("\n\nPDN ONLY query \n\n")

    # 1.0 FILTER PHASE
    # Originaly we checked for containing PDN over before if blocks strlen >7. 
    # As a result, blocks that did not contain PDN but were over >7 did not get put into toolongDf,
    # so we should remove any blocks that are too long before even making sure it contains PDN.

    potentialDf = inputDf.copy()
    potentialDf['When'] = potentialDf['When'].str[:9]
    potentialDf = potentialDf.loc[:, ['Horse', 'When']]

    # 1.1 For each row that is too long (more than 1 block), remove from potentials. (CHECK)
    toolongDf = inputDf.copy()
    toolongDf['When'] = toolongDf['When'].str[:9]

    mask = (toolongDf['Blocks'].str.len() > 7)
    toolongDf = toolongDf.loc[mask]
    toolongDf = toolongDf.loc[:, ['Horse', 'When']]

    # https://stackoverflow.com/a/18184990
    ds1 = set([tuple(line) for line in potentialDf.values])
    ds2 = set([tuple(line) for line in toolongDf.values])
    nottoolongDf = pd.DataFrame(list(ds1.difference(ds2)))

    # 1.2 Must only contain PDN queries. 
    # Create a set of Horses, Dates that have at least a PDN query.
    # containsPDNdf = 
    potentialDf = inputDf.copy()
    potentialDf['When'] = potentialDf['When'].str[:9]
    potentialDf = potentialDf.loc[:, ['Horse', 'When', 'Blocks']]    
    
    containsPDNdf = potentialDf.copy()
    containsPDNdf = filterTable(potentialDf, "Blocks", "contains", "PDN")
    containsPDNdf = nonnullBlocks(containsPDNdf)
    containsPDNdf['When'] = containsPDNdf['When'].str[:9]
    # print("containsPDNdf\n", containsPDNdf)

    ds3 = set([tuple(line) for line in potentialDf.values])
    ds4 = set([tuple(line) for line in containsPDNdf.values])
    nonPDNdf = pd.DataFrame(list(ds3.difference(ds4)))
    # print("nonPDNdf\n", nonPDNdf)
    # nonPDNdf = nonPDNdf[~nonPDNdf[2].isnull()]
    nonPDNdf.dropna(how="all", inplace=True)
    print("nonPDNdf dropna\n", nonPDNdf)

    # Finally it's just the list of Days and Horses that only had PDN blocks (not including NULL)
    containsPDNlist = containsPDNdf.loc[:, ['Horse', 'When']]
    ds5 = set([tuple(line) for line in containsPDNlist.values])
    ds6 = set([tuple(line) for line in toolongDf.values])
    onlyPDNdf = pd.DataFrame(list(ds5.difference(ds6)))
    print("Horse & Date List\n", onlyPDNdf)
    # exportTable(onlyPDNdf, "/home/royal/Desktop/onlyPDNdf.csv")


    # # 2.0 FETCHING PHASE
    # # 2.1 for every row of onlyPDNdf, grab the corresponding horse and day from the inputDf

    # outputDf = pd.DataFrame(columns=inputDf.columns)
    # inputshortDf = inputDf.copy()
    # inputshortDf['When'] = inputshortDf['When'].str[:9]
    # for _, row in onlyPDNdf.iterrows():
    #     print("row[0]", row[0], "row[1]", row[1])
    #     mask1 = inputshortDf['Horse'] == row[0]
    #     mask2 = inputshortDf['When'] == row[1]
    #     tempDf = inputshortDf.where(mask1 & mask2)
    #     print(tempDf.dropna())
        
    #     # tempDf = filterTable(tempDf, "Horse", "==", row.Horse)
    #     # tempDf = filterTable(tempDf, "When", "==", row.When)
    #     #print(tempDf)
    #     #add row to output DF
    #     outputDf = outputDf.append(tempDf.dropna())
    #     print(outputDf)

    outputDf = pd.DataFrame(columns=inputDf.columns)
    # print("outputDF", outputDf)

    df1 = inputDf.copy()
    df1['When'] = df1['When'].str[:9]

    # Give back results from original df1 where the horse names and dates are the same.
    for _, row in onlyPDNdf.iterrows():
        #print("row.Horse", row.Horse, "row.When", row.When)
        tempDf =  df1.copy()
        # print("tempDf type:", type(tempDf), "\n", tempDf)
        tableFilter1 = tempDf['Horse'] == row[0]
        tableFilter2 = tempDf['When'] == row[1]
        tempDf.where(tableFilter1 & tableFilter2, inplace=True)
        tempDf.dropna(how="all", inplace=True)  
        # print(tempDf)
        #add row to output DF
        outputDf = outputDf.append(tempDf)

    # exportTable(outputDf, "/home/royal/Desktop/alltrials_ONLYPDNdf.csv")

    df0 = outputDf.copy()
    df0 = filterTable(df0, "Trial", "==", "Straight Line")
    # df0 = filterTable(df0, "Trial", "==", "1")
    df0 = filterTable(df0, "Fore Strides", ">", "19")
    return df0

def queryOnlyPDNmerged(inputDf):
    blockstr = '1'
    print("\n\nPDN ONLY query \nblockstr", blockstr, "\n")

    # 1.0 FILTER PHASE
    # Originaly we checked for containing PDN over before if blocks strlen >7. 
    # As a result, blocks that did not contain PDN but were over >7 did not get put into toolongDf,
    # so we should remove any blocks that are too long before even making sure it contains PDN.

    potentialDf = inputDf.copy()
    potentialDf['When'] = potentialDf['When'].str[:11]
    potentialDf = potentialDf.loc[:, ['Horse', 'When']]

    # 1.1 For each row that is too long (more than 1 block), remove from potentials. (CHECK)
    toolongDf = inputDf.copy()
    toolongDf['When'] = toolongDf['When'].str[:11]

    mask = (toolongDf['Blocks'].str.len() > 4)
    toolongDf = toolongDf.loc[mask]
    toolongDf = toolongDf.loc[:, ['Horse', 'When']]

    # https://stackoverflow.com/a/18184990
    ds1 = set([tuple(line) for line in potentialDf.values])
    ds2 = set([tuple(line) for line in toolongDf.values])
    nottoolongDf = pd.DataFrame(list(ds1.difference(ds2)))

    # 1.2 Must only contain PDN queries. 
    # Create a set of Horses, Dates that have at least a PDN query.
    # containsPDNdf = 
    potentialDf = inputDf.copy()
    potentialDf['When'] = potentialDf['When'].str[:11]
    potentialDf = potentialDf.loc[:, ['Horse', 'When', 'Blocks']]    
    
    containsPDNdf = potentialDf.copy()
    containsPDNdf = filterTable(potentialDf, "Blocks", "contains", blockstr)
    containsPDNdf = nonnullBlocks(containsPDNdf)
    containsPDNdf['When'] = containsPDNdf['When'].str[:11]
    # print("containsPDNdf\n", containsPDNdf)

    ds3 = set([tuple(line) for line in potentialDf.values])
    ds4 = set([tuple(line) for line in containsPDNdf.values])
    nonPDNdf = pd.DataFrame(list(ds3.difference(ds4)))
    # print("nonPDNdf\n", nonPDNdf)
    # nonPDNdf = nonPDNdf[~nonPDNdf[2].isnull()]
    nonPDNdf.dropna(how="all", inplace=True)
    print("nonPDNdf dropna\n", nonPDNdf)

    # Finally it's just the list of Days and Horses that only had PDN blocks (not including NULL)
    containsPDNlist = containsPDNdf.loc[:, ['Horse', 'When']]
    ds5 = set([tuple(line) for line in containsPDNlist.values])
    ds6 = set([tuple(line) for line in toolongDf.values])
    onlyPDNdf = pd.DataFrame(list(ds5.difference(ds6)))
    print("Horse & Date List\n", onlyPDNdf)
    # exportTable(onlyPDNdf, "/home/royal/Desktop/onlyPDNdf.csv")


    # # 2.0 FETCHING PHASE
    # # 2.1 for every row of onlyPDNdf, grab the corresponding horse and day from the inputDf

    # outputDf = pd.DataFrame(columns=inputDf.columns)
    # inputshortDf = inputDf.copy()
    # inputshortDf['When'] = inputshortDf['When'].str[:9]
    # for _, row in onlyPDNdf.iterrows():
    #     print("row[0]", row[0], "row[1]", row[1])
    #     mask1 = inputshortDf['Horse'] == row[0]
    #     mask2 = inputshortDf['When'] == row[1]
    #     tempDf = inputshortDf.where(mask1 & mask2)
    #     print(tempDf.dropna())
        
    #     # tempDf = filterTable(tempDf, "Horse", "==", row.Horse)
    #     # tempDf = filterTable(tempDf, "When", "==", row.When)
    #     #print(tempDf)
    #     #add row to output DF
    #     outputDf = outputDf.append(tempDf.dropna())
    #     print(outputDf)

    outputDf = pd.DataFrame(columns=inputDf.columns)
    # print("outputDF", outputDf)

    df1 = inputDf.copy()
    df1['When'] = df1['When'].str[:11]

    # Give back results from original df1 where the horse names and dates are the same.
    for _, row in onlyPDNdf.iterrows():
        print("row.Horse", row[0], "row.When", row[1])
        tempDf =  df1.copy()
        print("tempDf type:", type(tempDf), "\n", tempDf)
        tableFilter1 = tempDf['Horse'] == row[0]
        tableFilter2 = tempDf['When'] == row[1]
        tempDf.where(tableFilter1 & tableFilter2, inplace=True)
        tempDf.dropna(how="all", inplace=True)  
        print(tempDf)
        #add row to output DF
        outputDf = outputDf.append(tempDf)
        # print(outputDf)
        # break

    # exportTable(outputDf, "/home/royal/Desktop/alltrials_ONLYPDNdf.csv")

    df0 = outputDf.copy()
    # df0 = filterTable(df0, "Trial", "==", "Straight Line")
    df0 = filterTable(df0, "Trial", "==", "1")
    df0 = filterTable(df0, "Fore Strides", ">", "19")
    return df0
"""
def goQuery1(df1):
    
    print("\nQUERY 1 ipsilateral impact")
    
    # query 1 ipsilateral impact has 6 parts:
    # 1. straight line trials
    df1 = filterTable(df1, "Trial", "==", "Straight Line")
    # 2. no blocks
    df1 = filterTable(df1, "Blocks", "==", "Null")
    # 3. at least twenty strides (use fore)
    df1 = filterTable(df1, "Fore Strides", ">=", "20")
    # 4. VS > 8.5 (absolute value)
    df1 = filterTable(df1, "Fore Signed Vector Sum", ">", "8.5", absvalue=True)
    # 5. diffMIN pelvis >3 (absolute value)
    df1 = filterTable(df1, "Hind Diff Min Mean", ">", "3", absvalue=True)
    # 6. sign of diffminpelvis same as sign of diffminhead
    df1 = filterTable(df1, "Hind Diff Min Mean", "Same Signs", "Fore Diff Min Mean")

    #print("\n\nQUERY 1 after dropna (finished filtering)\n\n", inputDf
    #print("inputDf is a ", type(inputDf))
    
    return df1

def goQuery2(df1): 
    print("\nQUERY 2 ipsilateral pushoff")
    
    # 1. straight line trials
    df1 = filterTable(df1, "Trial", "==", "Straight Line")
    # 2. no blocks
    df1 = filterTable(df1, "Blocks", "==", "Null")
    # 3. at least twenty strides (use fore)
    df1 = filterTable(df1, "Fore Strides", ">=", "20")
    # 4. VS > 8.5 (absolute value)
    df1 = filterTable(df1, "Fore Signed Vector Sum", ">", "8.5", absvalue=True)
    # 5. diffMAX pelvis >3 (absolute value)
    df1 = filterTable(df1, "Hind Diff Max Mean", ">", "3", absvalue=True)
    # 6. sign of diffmaxpelvis same as sign of diffminhead
    df1 = filterTable(df1, "Hind Diff Max Mean", "Same Signs", "Fore Diff Min Mean")

    return df1  


def goQuery3(df1): 
    print("\nQUERY 3 ipsilateral mostly impact")
    
    # 1. straight line trials
    df1 = filterTable(df1, "Trial", "==", "Straight Line")
    # 2. no blocks
    df1 = filterTable(df1, "Blocks", "==", "Null")
    # 3. at least twenty strides (use fore)
    df1 = filterTable(df1, "Fore Strides", ">=", "20")
    # 4. VS > 8.5 (absolute value)
    df1 = filterTable(df1, "Fore Signed Vector Sum", ">", "8.5", absvalue=True)
    # 5. diffMIN pelvis >3 (absolute value)
    df1 = filterTable(df1, "Hind Diff Min Mean", ">", "3", absvalue=True)
    # 6. diffMAX pelvis >3 (absolute value)
    df1 = filterTable(df1, "Hind Diff Max Mean", ">", "3", absvalue=True)
    # 7. sign of diffminpelvis same as sign of diffmaxpelvis
    df1 = filterTable(df1, "Hind Diff Min Mean", "Same Signs", "Hind Diff Max Mean")
    # 8. sign of diffminpelvis same as sign of diffminhead
    df1 = filterTable(df1, "Hind Diff Min Mean", "Same Signs", "Fore Diff Min Mean")
    # 9. |diffMIN pelvis| > |diffMAX pelvis|
    # df1 = filterTable(df1, "Hind Diff Min Mean", ">", "Hind Diff Max Mean", absvalue=True)

    return df1


def goQuery5(df1):
    print("\nQUERY 5 just impact")

    # straight line trials
    df1 = filterTable(df1, "Trial", "==", "Straight Line")
    # no blocks
    df1 = filterTable(df1, "Blocks", "==", "Null")
    # at least twenty strides (use fore)
    df1 = filterTable(df1, "Fore Strides", ">=", "20")
    # VS < 8.5 (absolute value)
    df1 = filterTable(df1, "Fore Signed Vector Sum", "<", "8.5", absvalue=True)
    # diffMIN pelvis >3 (absolute value)
    df1 = filterTable(df1, "Hind Diff Min Mean", ">", "3", absvalue=True)
    # sign of diffminpelvis same as sign of diffminhead
    df1 = filterTable(df1, "Hind Diff Min Mean", "Same Signs", "Fore Diff Min Mean")
    
    return df1


def goQuery6(df1):
    print("\nQUERY 6 just pushoff")

    # straight line trials
    df1 = filterTable(df1, "Trial", "==", "Straight Line")
    # no blocks
    df1 = filterTable(df1, "Blocks", "==", "Null")
    # at least twenty strides (use fore)
    df1 = filterTable(df1, "Fore Strides", ">=", "20")
    # VS < 8.5 (absolute value)
    df1 = filterTable(df1, "Fore Signed Vector Sum", "<", "8.5", absvalue=True)
    # diffMAX pelvis >3 (absolute value)
    df1 = filterTable(df1, "Hind Diff Max Mean", ">", "3", absvalue=True)
    # sign of diffmaxpelvis same as sign of diffminhead
    df1 = filterTable(df1, "Hind Diff Max Mean", "Same Signs", "Fore Diff Min Mean")
    
    return df1

"""

def nullBlocks(inputDf):
    
    #print("\n\nNullBlocks activated on: \n\ninputDf", inputDf)

    #print("inputDf is a ", type(inputDf))
    # pandas filtering. 

    # 2. no blocks
    inputDf = inputDf[inputDf['Blocks'].isnull()]
    
    #print("inputDf is a ", type(inputDf))   
    #print("after where\n\n", inputDf)
    inputDf.dropna(how="all", inplace=True)
    #print("\n\nDropna in NullBlocks (finished filtering)\n\n", inputDf)
    
    #print("inputDf is a ", type(inputDf))
  
    return inputDf

def nonnullBlocks(inputDf):
    
    #print("\n\nNullBlocks activated on: \n\ninputDf", inputDf)

    #print("inputDf is a ", type(inputDf))
    # pandas filtering. 

    # 2. no blocks
    inputDf = inputDf[~inputDf['Blocks'].isnull()]
    
    #print("inputDf is a ", type(inputDf))   
    #print("after where\n\n", inputDf)
    inputDf.dropna(how="all", inplace=True)
    #print("\n\nDropna in NullBlocks (finished filtering)\n\n", inputDf)
    
    #print("inputDf is a ", type(inputDf))
  
    return inputDf

def filterTable(df, column, operator, value, absvalue="None"):
    # print("\nfiltering", column, operator, value)
    #the conditional operators: (>, <, >=, <=, ==, !=)
    #also, for absolute value there will be more
    if (value == "Null" and column == "Blocks" and operator == "=="):
        df = nullBlocks(df)
        return df
        # print(df[column])
    elif (operator == "contains"):
        contain_values = df[df[column].str.contains(value, na=False, regex=False)]
        # print(contain_values)
        df.dropna(how="all", inplace=True)
        return contain_values
    if (operator == "Same Signs"):
        tableFilter = df[column] * df[value] > 0
        df.where(tableFilter, inplace=True)
        df.dropna(how="all", inplace=True)
        return df
    if (operator == "Opposite Signs"):
        tableFilter = df[column] * df[value] < 0
        df.where(tableFilter, inplace=True)
        df.dropna(how="all", inplace=True)
        return df
    else:
        # parse operator
        operate = op.eq
        if (operator == "=="):
            operate = op.eq
        elif (operator == ">"):
            operate = op.gt
        elif (operator == "<"):
            operate = op.lt
        elif (operator == ">="):
            operate = op.ge
        elif (operator == "<="):
            operate = op.le
        elif (operator == "!="):
            operate = op.ne
        

        # a function to determine if value is a string, number, or column
        valueType = "string"
        if (is_number(value) & isinstance(value, str)):
            value = float(value)
            valueType = "number"
        if (value in Columns):
            valueType = "column"

        print(valueType)
        print(value)

        if (absvalue == "Both"):
            print("abs both")
            if (valueType == "column"):
                print("both column")
                tableFilter = operate(abs(df[column]), abs(df[value]))
                df.where(tableFilter, inplace=True)

            if (valueType == "number"):
                print("both number")
                tableFilter = operate(abs(df[column]), abs(value))
                df.where(tableFilter, inplace=True)

        elif (absvalue == "Left"):   
            print("abs left")
            if (valueType == "column"):
                print("left column")
                tableFilter = operate(abs(df[column]), df[value])
                df.where(tableFilter, inplace=True)

            if (valueType == "number"):
                print("left number")
                tableFilter = operate(abs(df[column]), value)
                df.where(tableFilter, inplace=True)

        elif (absvalue == "Right"):
            print("abs right")
            if (valueType == "column"):
                print("right column")
                tableFilter = operate(df[column], abs(df[value]))
                df.where(tableFilter, inplace=True)

            if (valueType == "number"):
                print("right number")
                tableFilter = operate(df[column], abs(value))
                df.where(tableFilter, inplace=True) 

        else:    #abs is none
            print("abs none")
            if (valueType == "column"):
                print("none column")
                tableFilter = operate(df[column], df[value])
                df.where(tableFilter, inplace=True)
            else:
                print("none string or number")
                tableFilter = operate(df[column], value)
                df.where(tableFilter, inplace=True)

    df.dropna(how="all", inplace=True)
    return df